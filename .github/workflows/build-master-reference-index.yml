name: Build MasterReference Index

on:
  workflow_run:
    workflows: ["Build MasterSuite Index"]
    types: [completed]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: masterreference-index
  cancel-in-progress: false

jobs:
  build-mri:
    if: 
      github.event_name != 'workflow_run' || 
      github.event.workflow_run.conclusion == 'success'
    name: Build MRI
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - uses: actions/setup-node@v4
        with: { node-version: 'lts/*', cache: 'npm' }

      - name: Install deps
        run: npm ci

      - name: Build MasterReferenceIndex (full replay + prune)
        run: |
          node src/main/scripts/buildMasterReferenceIndex.js \
            --in src/main/data/documents.json \
            --audit-out src/main/reports/mri_presence_audit.json

      - name: Sanity check invariant sourcePath (if you add it)
        run: |
          test -f src/main/reports/masterReferenceIndex.json || { echo "MRI not emitted"; exit 1; }

      - name: Fetch baseline
        run: |
          git fetch --no-tags --depth=1 origin +refs/heads/${{ github.event.repository.default_branch }}:refs/remotes/origin/${{ github.event.repository.default_branch }}
          git show origin/${{ github.event.repository.default_branch }}:src/main/reports/masterReferenceIndex.json > baseline.json || echo '{}' > baseline.json

      - name: Normalize & classify changes
        run: |
          jq 'del(.generatedAt)' src/main/reports/masterReferenceIndex.json > report.norm.json
          jq 'del(.generatedAt)' baseline.json > baseline.norm.json
          node -e "
            const fs=require('fs');
            const a=JSON.parse(fs.readFileSync('baseline.norm.json','utf8')||'{}');
            const b=JSON.parse(fs.readFileSync('report.norm.json','utf8')||'{}');
            const onlyMeta = JSON.stringify(a)===JSON.stringify(b);
            // Presence audit
            const audit = JSON.parse(fs.readFileSync('src/main/reports/mri_presence_audit.json','utf8'));
            const missingCount = audit.missingCount||0;
            fs.writeFileSync('mri-change-class.json', JSON.stringify({ onlyMeta, missingCount }, null, 2));
          "
          cat mri-change-class.json

      - name: Decide path
        id: decide_mri
        run: |
          echo "onlyMeta=$(jq -r '.onlyMeta' mri-change-class.json)" >> $GITHUB_OUTPUT
          echo "missing=$(jq -r '.missingCount' mri-change-class.json)" >> $GITHUB_OUTPUT
          echo "onlyMeta=$(jq -r '.onlyMeta' mri-change-class.json)"


      - name: Commit MRI metadata-only change
        if: steps.decide_mri.outputs.onlyMeta == 'true'
        run: |
          set -e
          BR="${{ github.event.repository.default_branch }}"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          # Stage both MRI and audit if present
          [ -f src/main/reports/masterReferenceIndex.json ] && git add src/main/reports/masterReferenceIndex.json || true
          [ -f src/main/reports/mri_presence_audit.json ] && git add src/main/reports/mri_presence_audit.json || true
          if git diff --cached --quiet; then
            echo "No metadata-only changes to commit.";
            exit 0;
          fi
          # Commit on the current checkout and push to the default branch ref
          git commit -m "chore: refresh MasterReferenceIndex metadata timestamp"
          # Fast-forward push from detached HEAD to the branch ref
          git push origin HEAD:"$BR"
          echo "✅ Metadata-only MasterReferenceIndex refresh committed to $BR"

      - name: Render PR body (MRI)
        id: render_pr_mri
        if: steps.decide_mri.outputs.onlyMeta != 'true'
        run: |
          MISSING="${{ steps.decide_mri.outputs.missing }}"
          {
            printf '%s\n' 'Automated MRI build detected content changes.'
            printf '%s\n' ""
            printf '%s\n' "**Missing refs**: ${MISSING}"
          } > mri_pr_body.txt
          sed -n '1,120p' mri_pr_body.txt

      - name: Create PR for MRI
        id: create_pr_mri
        if: steps.decide_mri.outputs.onlyMeta != 'true' && !startsWith(github.ref, 'refs/heads/chore/build-masterreference')
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "chore: Build MasterReferenceIndex (data change)"
          title: "Build MasterReferenceIndex (data change)"
          body-path: mri_pr_body.txt
          branch: chore/build-masterreference
          add-paths: |
            src/main/reports/masterReferenceIndex.json
            src/main/reports/mri_presence_audit.json
          labels: automated, reports, mri
          delete-branch: true
          base: ${{ github.event.repository.default_branch }}

      - name: Emit skip-site-build marker (MRI PR)
        if: steps.decide_mri.outputs.onlyMeta != 'true'
        run: |
          mkdir -p .emit
          PR=${{ steps.create_pr_mri.outputs.pull-request-number }}
          echo "PR created by MRI workflow at ${{ github.run_id }} (PR #${PR})" > .emit/skip-site-build.txt

      - name: Upload skip-site-build artifact (MRI)
        if: steps.decide_mri.outputs.onlyMeta != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: skip-site-build-pr-${{ steps.create_pr_mri.outputs.pull-request-number }}
          path: .emit/skip-site-build.txt
          retention-days: 3

      - name: Ensure issues for missing refs (idempotent)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = 'src/main/reports/mri_presence_audit.json';
            const audit = JSON.parse(fs.readFileSync(path, 'utf8'));
            const missing = Array.isArray(audit.missing) ? audit.missing : [];

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Current missing set and quick lookup
            const currentMissing = new Set(missing.map(m => m.refId));
            const byRef = new Map(missing.map(m => [m.refId, m]));

            // Helper: list open issues with label 'missing-ref' and title prefix
            async function listOpenMissingIssues() {
              const all = await github.paginate(github.rest.issues.listForRepo, {
                owner, repo, state: 'open', labels: 'missing-ref'
              });
              return all.filter(i => i.title && i.title.startsWith('MISSING REF: '));
            }

            const openIssues = await listOpenMissingIssues();
            const openByTitle = new Map(openIssues.map(i => [i.title, i]));

            // Upsert issues for each currently-missing ref
            const labels = ['automated', 'mri', 'missing-ref'];
            const runTag = `Run #${context.runId}`;

            function formatSightings(m, max = 10) {
              const arr = (m.sightings || []).slice(0, max);
              if (arr.length === 0) return '- (none listed)';
              return arr.map(s => {
                const parts = [`- ${s.docId || '(unknown doc)'} (${s.type || '?'})`];
                const extras = [];
                if (s.cite) extras.push(` - _cite:_ ` + s.cite);
                if (s.title) extras.push(` - _title:_ ` + s.title);
                if (s.href) extras.push(` - _href:_ ` + s.href);
                if (s.rawRef) extras.push(` - _rawRef:_ ` + s.rawRef);
                if (extras.length) parts[0] += '\n_Source info:_\n ' + extras.join(' \n ');
                return parts.join('');
              }).join('\n');
            }

            for (const m of missing) {
              const title = `MISSING REF: ${m.refId}`;
              const stamp = new Date().toISOString().slice(0,10);
              const body = [
                `Detected as MISSING`,
                `RefId: **${m.refId}**`,
                `Sightings: **${m.sightingCount}**`,
                '',
                'First few sightings:',
                formatSightings(m, 10),
                '',
                `_Created automatically from MRI presence audit on ${stamp} — ${runTag}_`
              ].join('\n');

              const existing = openByTitle.get(title);
              if (existing) {
                await github.rest.issues.update({ owner, repo, issue_number: existing.number, body, labels });
              } else {
                await github.rest.issues.create({ owner, repo, title, body, labels });
              }
            }

            // Close resolved issues (those no longer in current audit)
            for (const issue of openIssues) {
              const refId = issue.title.replace(/^MISSING REF: /, '');
              if (!currentMissing.has(refId)) {
                await github.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: `Resolved: no longer reported as MISSING REF. ${runTag}. Closing.` });
                await github.rest.issues.update({ owner, repo, issue_number: issue.number, state: 'closed' });
              }
            }