name: Build MasterSuite Index

on:
  schedule:
    - cron: "15 16 * * *"   # 09:15 PT (cron uses UTC)
  workflow_dispatch:        # Manual run for testing

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: mastersuite-index
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          cache: 'npm'

      - name: Install deps
        run: npm ci

      - name: Build MasterSuiteIndex
        run: |
          node src/main/scripts/buildMasterSuiteIndex.js \
            --in src/main/data/documents.json \
            --out src/main/reports/masterSuiteIndex.json \
            --pub-out src/main/reports/masterSuiteIndex-publisherCounts.json \
            --skips-out src/main/reports/masterSuiteIndex-skippedDocs.json

      - name: Sanity check invariant sourcePath
        run: |
          jq -e '.sourcePath == "src/main/data/documents.json"' src/main/reports/masterSuiteIndex.json >/dev/null \
            || (echo "sourcePath changed; failing run"; exit 1)

      - name: Fetch baseline
        run: |
          git fetch --no-tags --depth=1 origin +refs/heads/${{ github.event.repository.default_branch }}:refs/remotes/origin/${{ github.event.repository.default_branch }}
          git show origin/${{ github.event.repository.default_branch }}:src/main/reports/masterSuiteIndex.json > baseline.json || echo '{}' > baseline.json

      - name: Normalize reports for diff
        run: |
          jq 'del(.generatedAt, .sourceHash)' src/main/reports/masterSuiteIndex.json > report.norm.json
          jq 'del(.generatedAt, .sourceHash)' baseline.json > baseline.norm.json
          node -e "const fs=require('fs'); const path=require('path'); const a=JSON.parse(fs.readFileSync('baseline.norm.json','utf8')||'{}'); const b=JSON.parse(fs.readFileSync('report.norm.json','utf8')||'{}'); const onlyMeta=JSON.stringify(a)===JSON.stringify(b); const lineageChanged=JSON.stringify((a||{}).lineages||[])!==JSON.stringify((b||{}).lineages||[]); const flagSummaryChanged=JSON.stringify((a||{}).flagSummary||{})!==JSON.stringify((b||{}).flagSummary||{}); fs.writeFileSync('change-class.json', JSON.stringify({onlyMeta,lineageChanged,flagSummaryChanged},null,2));"

      - name: Decide path
        id: decide
        run: |
          echo "onlyMeta=$(jq -r '.onlyMeta' change-class.json)" >> $GITHUB_OUTPUT
          echo "lineage=$(jq -r '.lineageChanged' change-class.json)" >> $GITHUB_OUTPUT
          echo "flags=$(jq -r '.flagSummaryChanged' change-class.json)" >> $GITHUB_OUTPUT

      - name: Upload artifacts (snapshot)
        uses: actions/upload-artifact@v4
        with:
          name: mastersuite-${{ github.run_id }}
          path: |
            src/main/reports/masterSuiteIndex.json
            src/main/reports/masterSuiteIndex-publisherCounts.json
            src/main/reports/masterSuiteIndex-skippedDocs.json
          if-no-files-found: ignore
          retention-days: 30

      - name: Auto-commit metadata-only change to default branch
        if: steps.decide.outputs.onlyMeta == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add src/main/reports/masterSuiteIndex.json
          git diff --cached --quiet || git commit -m "chore(reports): MasterSuiteIndex metadata refresh (generatedAt/sourceHash)"
          git push

      - name: Compute PR file list
        id: files
        run: |
          files="src/main/reports/masterSuiteIndex.json"
          [ -f src/main/reports/masterSuiteIndex-publisherCounts.json ] && files="$files"$'\n''src/main/reports/masterSuiteIndex-publisherCounts.json'
          [ -f src/main/reports/masterSuiteIndex-skippedDocs.json ] && files="$files"$'\n''src/main/reports/masterSuiteIndex-skippedDocs.json'
          echo "paths<<EOF" >> $GITHUB_OUTPUT
          echo "$files" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create PR for content changes
        if: steps.decide.outputs.lineage == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "chore(reports): MasterSuiteIndex (data change)"
          title: "Nightly MasterSuiteIndex (data change)"
          body: |
            Automated nightly build detected content changes.
            - lineageChanged: ${{ steps.decide.outputs.lineage }}
            - flagSummaryChanged: ${{ steps.decide.outputs.flags }}
          branch: chore/nightly-mastersuite
          add-paths: ${{ steps.files.outputs.paths }}
          labels: automated, reports

      - name: File/update Issue for UNKEYED (optional gate)
        if: steps.decide.outputs.flags == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = JSON.parse(fs.readFileSync('src/main/reports/masterSuiteIndex.json','utf8'));
            const info = report.flagSummary?.byType?.UNKEYED;
            if (!info || !info.count) { core.info('No UNKEYED flags.'); return; }
            const examples = (info.examples || []).slice(0, 10).map(e => `- ${e.lineage || e.docId || JSON.stringify(e)}`).join('\n');
            const title = `UNKEYED present in nightly report (${info.count})`;
            const body = `Detected ${info.count} UNKEYED items.\n\nTop examples:\n${examples}\n\nAction: extend keying in buildMasterSuiteIndex.js.`;
            const { data: issues } = await github.rest.issues.listForRepo({ owner: context.repo.owner, repo: context.repo.repo, state: 'open', labels: 'automated,unkeyed' });
            const existing = issues.find(i => i.title.startsWith('UNKEYED present'));
            if (existing) {
              await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: existing.number, body });
            } else {
              await github.rest.issues.create({ owner: context.repo.owner, repo: context.repo.repo, title, body, labels: ['automated','unkeyed'] });
            }