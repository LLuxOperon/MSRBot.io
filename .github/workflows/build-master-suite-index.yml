name: Build MasterSuite Index
    
on:
  push:
    branches: [ main ]
  schedule:
    - cron: "30 06 * * *" # 23:30 PT (cron in UTC)
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: mastersuite-index
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          cache: 'npm'

      - name: Install deps
        run: npm ci

      - name: Build MasterSuiteIndex
        run: |
          node src/main/scripts/buildMasterSuiteIndex.js \
            --in src/main/data/documents.json \
            --out src/main/reports/masterSuiteIndex.json \
            --pub-out src/main/reports/masterSuiteIndex-publisherCounts.json \
            --skips-out src/main/reports/masterSuiteIndex-skippedDocs.json

      - name: Sanity check invariant sourcePath
        run: |
          jq -e '.sourcePath == "src/main/data/documents.json"' src/main/reports/masterSuiteIndex.json >/dev/null \
            || (echo "sourcePath changed; failing run"; exit 1)

      - name: Fetch baseline
        run: |
          git fetch --no-tags --depth=1 origin +refs/heads/${{ github.event.repository.default_branch }}:refs/remotes/origin/${{ github.event.repository.default_branch }}
          git show origin/${{ github.event.repository.default_branch }}:src/main/reports/masterSuiteIndex.json > baseline.json || echo '{}' > baseline.json

      - name: Normalize reports for diff
        run: |
          jq 'del(.generatedAt, .sourceHash)' src/main/reports/masterSuiteIndex.json > report.norm.json
          jq 'del(.generatedAt, .sourceHash)' baseline.json > baseline.norm.json
          node -e "
            const fs=require('fs');
            const getUnkeyed = (obj)=>{
              const out=new Set();
              const byPub=((obj||{}).skippedDocs||{}).byPublisher||{};
              for(const block of Object.values(byPub)){
                for(const it of (block.items||[])){
                  if(it && it.reason==='UNKEYED'){
                    const id=(it.key||it.docId||'').trim();
                    if(id) out.add(id);
                  }
                }
              }
              return Array.from(out).sort();
            };
            const a=JSON.parse(fs.readFileSync('baseline.norm.json','utf8')||'{}');
            const b=JSON.parse(fs.readFileSync('report.norm.json','utf8')||'{}');
            const onlyMeta=JSON.stringify(a)===JSON.stringify(b);
            const lineageChanged=JSON.stringify((a||{}).lineages||[])!==JSON.stringify((b||{}).lineages||[]);
            const flagSummaryChanged=JSON.stringify((a||{}).flagSummary||{})!==JSON.stringify((b||{}).flagSummary||{});
            const prevUnkeyed=getUnkeyed(a);
            const currUnkeyed=getUnkeyed(b);
            const prevSet=new Set(prevUnkeyed), currSet=new Set(currUnkeyed);
            const resolved=prevUnkeyed.filter(x=>!currSet.has(x));
            const introduced=currUnkeyed.filter(x=>!prevSet.has(x));
            const unkeyedBefore=prevUnkeyed.length, unkeyedNow=currUnkeyed.length;
            const unkeyedChanged=unkeyedBefore!==unkeyedNow || introduced.length>0 || resolved.length>0;
            // Inventory change detection
            const docsTotalA = (a.publisherCounts && a.publisherCounts.total) || 0;
            const docsTotalB = (b.publisherCounts && b.publisherCounts.total) || 0;
            const inventoryChanged = docsTotalA !== docsTotalB;
            fs.writeFileSync('change-class.json', JSON.stringify({
              onlyMeta,lineageChanged,flagSummaryChanged,
              unkeyedBefore,unkeyedNow,unkeyedChanged,
              currUnkeyed,prevUnkeyed,resolved,introduced,
              inventoryChanged, docsTotalA, docsTotalB
            },null,2));
          "

      - name: Decide path
        id: decide
        run: |
          echo "onlyMeta=$(jq -r '.onlyMeta' change-class.json)" >> $GITHUB_OUTPUT
          echo "lineage=$(jq -r '.lineageChanged' change-class.json)" >> $GITHUB_OUTPUT
          echo "flags=$(jq -r '.flagSummaryChanged' change-class.json)" >> $GITHUB_OUTPUT
          echo "unkeyedChanged=$(jq -r '.unkeyedChanged' change-class.json)" >> $GITHUB_OUTPUT
          echo "unkeyedNow=$(jq -r '.unkeyedNow' change-class.json)" >> $GITHUB_OUTPUT
          echo "unkeyedBefore=$(jq -r '.unkeyedBefore' change-class.json)" >> $GITHUB_OUTPUT
          echo "inventoryChanged=$(jq -r '.inventoryChanged' change-class.json)" >> $GITHUB_OUTPUT
          echo "docsTotalDelta=$(( $(jq -r '.docsTotalB' change-class.json) - $(jq -r '.docsTotalA' change-class.json) ))" >> $GITHUB_OUTPUT

      - name: Render PR body
        id: render_pr
        if: steps.decide.outputs.lineage == 'true' || steps.decide.outputs.inventoryChanged == 'true'
        run: |
          echo "Building PR body from change-class.json"
          UNKEYED_BEFORE=$(jq -r '.unkeyedBefore' change-class.json)
          UNKEYED_NOW=$(jq -r '.unkeyedNow' change-class.json)
          CURR_LIST=$(jq -r '.currUnkeyed[]? | "- " + .' change-class.json)

          # Provide fallback if list is empty
          if [ -z "$CURR_LIST" ]; then CURR_LIST="- (none)"; fi

          {
            printf '%s\n' 'Automated MSI build detected content changes.'
            printf '%s\n' ''
            printf '%s\n' '**Flags**'
            printf '%s\n' "- lineageChanged: ${{ steps.decide.outputs.lineage }}"
            printf '%s\n' "- flagSummaryChanged: ${{ steps.decide.outputs.flags }}"
            printf '%s\n' "- inventoryChanged: ${{ steps.decide.outputs.inventoryChanged }} (Δ total: ${{ steps.decide.outputs.docsTotalDelta }})"
            printf '%s\n' ''
            printf '%s\n' '**UNKEYED (informational — merge does not auto-close)**'
            printf '%s\n' "- Previously UNKEYED count: ${UNKEYED_BEFORE}"
            printf '%s\n' "- Currently UNKEYED count:  ${UNKEYED_NOW}"
            printf '%s\n' ''
            printf '%s\n' '**Still UNKEYED on this branch:**'
            printf '%s\n' "${CURR_LIST}"
          } > pr_body.txt

          sed -n '1,200p' pr_body.txt

      - name: Upload artifacts (snapshot)
        uses: actions/upload-artifact@v4
        with:
          name: mastersuite-${{ github.run_id }}
          path: |
            src/main/reports/masterSuiteIndex.json
            src/main/reports/masterSuiteIndex-publisherCounts.json
            src/main/reports/masterSuiteIndex-skippedDocs.json
          if-no-files-found: ignore
          retention-days: 30

      - name: Auto-commit metadata-only change to default branch
        if: |
          steps.decide.outputs.onlyMeta == 'true' ||
          (steps.decide.outputs.lineage == 'false' &&
           steps.decide.outputs.inventoryChanged == 'false' &&
           (steps.decide.outputs.unkeyedChanged == 'true' || steps.decide.outputs.flags == 'true'))
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add src/main/reports/masterSuiteIndex.json
          git diff --cached --quiet || git commit -m "chore: MasterSuiteIndex metadata refresh"
          git push 

      - name: Compute PR file list
        id: files
        run: |
          files="src/main/reports/masterSuiteIndex.json"
          [ -f src/main/reports/masterSuiteIndex-publisherCounts.json ] && files="$files"$'\n''src/main/reports/masterSuiteIndex-publisherCounts.json'
          [ -f src/main/reports/masterSuiteIndex-skippedDocs.json ] && files="$files"$'\n''src/main/reports/masterSuiteIndex-skippedDocs.json'
          echo "paths<<EOF" >> $GITHUB_OUTPUT
          echo "$files" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create PR for content changes
        if: steps.decide.outputs.lineage == 'true' || steps.decide.outputs.inventoryChanged == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "chore: Build MasterSuiteIndex (data change)"
          title: "Build MasterSuiteIndex (data change)"
          body-path: pr_body.txt
          branch: chore/build-mastersuite
          add-paths: ${{ steps.files.outputs.paths }}
          labels: automated, msi, reports
          delete-branch: true

      - name: Ensure per-doc UNKEYED issues (one issue per docId; idempotent)
        if: ${{ github.ref == format('refs/heads/{0}', github.event.repository.default_branch) }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = 'src/main/reports/masterSuiteIndex.json';
            const report = JSON.parse(fs.readFileSync(path, 'utf8'));
            const byPub = report?.skippedDocs?.byPublisher || {};

            // Build the CURRENT set of UNKEYED doc identifiers (prefer 'key' if present, else docId)
            const currentUnkeyed = new Set();
            for (const block of Object.values(byPub)) {
              for (const it of (block.items || [])) {
                if (it?.reason === 'UNKEYED') {
                  const id = (it.key || it.docId || '').trim();
                  if (id) currentUnkeyed.add(id);
                }
              }
            }

            core.info(`Current UNKEYED count in report: ${currentUnkeyed.size}`);

            // Helper: fetch all open issues with label 'unkeyed' and title prefix 'UNKEYED: '
            async function listOpenUnkeyedIssues() {
              const issues = await github.paginate(
                github.rest.issues.listForRepo,
                { owner: context.repo.owner, repo: context.repo.repo, state: 'open', labels: 'unkeyed' }
              );
              return issues.filter(i => i.title.startsWith('UNKEYED: '));
            }

            // Helper: get or create issue for a specific doc key
            async function getOrCreateIssueForDoc(docKey, details) {
              const existing = (await listOpenUnkeyedIssues()).find(i => i.title === `UNKEYED: ${docKey}`);
              if (existing) {
                core.info(`UNKEYED issue already exists for ${docKey}`);
                return existing.number;
              } else {
                const stamp = new Date().toISOString().slice(0,10);
                const runTag = `Run #${context.runId}`;
                const body = [
                  `Detected as UNKEYED`,
                  `RefId: **${docKey}**\n`,
                  '',
                  'Context:',
                  `- Publisher: ${details.publisher || '(unknown)'}`,
                  `- Rule: ${details.rule || '(unknown)'}`,
                  `- Rule detail: ${details.ruleDetail || '(none)'}`,
                  details.lineageKey ? `- Lineage key: ${details.lineageKey}` : null,
                  '',
                  `\n_Created automatically from MSI on ${stamp} — ${runTag}_`
                ].filter(Boolean).join('\n');
                const created = await github.rest.issues.create({
                  owner: context.repo.owner, repo: context.repo.repo,
                  title: `UNKEYED: ${docKey}`,
                  body,
                  labels: ['automated','unkeyed','msi']
                });
                core.info(`Created UNKEYED issue #${created.data.number} for ${docKey}`);
                return created.data.number;
              }
            }

            // Map to collect per-doc details from report for nicer bodies
            const detailByKey = {};
            for (const [pub, block] of Object.entries(byPub)) {
              for (const it of (block.items || [])) {
                if (it?.reason === 'UNKEYED') {
                  const key = (it.key || it.docId || '').trim();
                  if (!key) continue;
                  detailByKey[key] = {
                    publisher: pub,
                    rule: it.rule,
                    ruleDetail: it.ruleDetail,
                    lineageKey: it.key
                  };
                }
              }
            }

            // 1) Ensure an issue exists per CURRENT unkeyed doc
            for (const docKey of currentUnkeyed) {
              await getOrCreateIssueForDoc(docKey, detailByKey[docKey] || {});
            }

            // 2) Close any stale UNKEYED issues whose docKey is no longer present
            const openIssues = await listOpenUnkeyedIssues();
            for (const issue of openIssues) {
              const docKey = issue.title.replace(/^UNKEYED: /,'');
              if (!currentUnkeyed.has(docKey)) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                  body: `Resolved: no longer reported as UNKEYED (Run #${context.runId}). Closing.`
                });
                await github.rest.issues.update({
                  owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number, state: 'closed'
                });
                core.info(`Closed resolved UNKEYED issue for ${docKey}`);
              }
            }
      - name: Log UNKEYED summary (post-issue handling)
        run: |
          echo "UNKEYED per-doc issues ensured. See repository issues labeled 'unkeyed' for details."